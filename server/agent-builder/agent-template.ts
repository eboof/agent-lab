// server/agent-builder/agent-template.ts (v2.0)

// Agent-Lab ESM Project – generated by ChatGPT
// Version ID: 20250828-1200

import type { AgentConfig } from "./agent.ts";

/**
 * Generate an Agent class file as a string, based on the provided config.
 * The generated class will extend BaseAgent and be ready to drop into /agents/.
 */
export const createAgentTemplate = (config: AgentConfig): string => {
  const className = toPascalCase(config.name) + "Agent";
  const { imports, logic } = generateExecuteLogic(config);

  return `// agents/${config.name.toLowerCase().replace(/\s+/g, "-")}.agent.ts
// Auto-generated by Agent Builder

import { BaseAgent } from "../server/agent-builder/agent.ts";
${imports}

export class ${className} extends BaseAgent {
  constructor() {
    super({
      name: "${config.name}",
      description: "${config.description}",
      version: "${config.version}",
      systemPrompt: ${JSON.stringify(config.prompt || "", null, 2)},
      tools: ${JSON.stringify(config.tools || [], null, 2)},
      inputSchema: ${JSON.stringify(config.inputSchema || {}, null, 2)},
      outputSchema: ${JSON.stringify(config.outputSchema || {}, null, 2)},
      dependencies: ${JSON.stringify(config.dependencies || [], null, 2)},
      environmentVars: ${JSON.stringify(config.environmentVars || [], null, 2)},
      timeout: ${config.timeout ?? 0},
      retries: ${config.retries ?? 0},
      memory: ${config.memory ?? false}
    });
  }

  protected async execute(input: Record<string, any>): Promise<any> {
    this.log("Starting execution with input:", input);
    
    try {
      // Your custom agent logic goes here
      // Access input fields: input.${Object.keys(config.inputSchema || {}).join(', input.')}
      
      ${logic}
      
      // Return structured output matching your output schema
      const result = {
        ${generateOutputStructure(config)}
        timestamp: new Date().toISOString(),
        agent: this.config.name
      };
      
      this.log("Execution completed successfully:", result);
      return result;
      
    } catch (error: any) {
      this.error("Execution failed:", error);
      throw error;
    }
  }
}

// Default export for Agent-Lab runner compatibility
export default async function run(args: string[]) {
  const agent = new ${className}();
  return await agent.run(args);
}
`;
};

/** Helper: convert "stock agent" → "StockAgent" */
function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
    .replace(/^./, (chr) => chr.toUpperCase());
}

/** Generate execute logic based on selected tools */
function generateExecuteLogic(config: AgentConfig): string {
  const tools = config.tools || [];
  const hasFinanceAPI = tools.some(t => typeof t === 'string' ? t === 'yahoo-finance' : t.id === 'yahoo-finance');
  const hasOpenAI = tools.some(t => typeof t === 'string' ? t === 'openai-api' : t.id === 'openai-api');
  const hasAnthropic = tools.some(t => typeof t === 'string' ? t === 'anthropic-api' : t.id === 'anthropic-api');
  const hasCLI = tools.some(t => typeof t === 'string' ? t === 'cli-tool' : t.id === 'cli-tool');
  
  let imports = '';
  let logic = `// Process based on selected tools\n`;
  
  // Add imports for selected tools
  if (hasFinanceAPI) {
    imports += `import { YahooFinanceTool } from "../server/tools/implementations/yahoo-finance-tool.ts";\n`;
  }
  if (hasOpenAI) {
    imports += `import { OpenAITool } from "../server/tools/implementations/openai-tool.ts";\n`;
  }
  if (hasAnthropic) {
    imports += `import { AnthropicTool } from "../server/tools/implementations/anthropic-tool.ts";\n`;
  }
  if (hasCLI) {
    imports += `import { CLITool } from "../server/tools/implementations/cli-tool.ts";\n`;
  }
  
  // Generate actual working logic
  if (hasFinanceAPI) {
    logic += `      // Yahoo Finance integration - get real stock data\n`;
    logic += `      let stockData = null;\n`;
    logic += `      if (input.symbol) {\n`;
    logic += `        try {\n`;
    logic += `          stockData = await YahooFinanceTool.getStockAnalysis(input.symbol, input.period || '1mo');\n`;
    logic += `          this.log("Retrieved stock data for", input.symbol);\n`;
    logic += `        } catch (error: any) {\n`;
    logic += `          this.error("Failed to get stock data:", error.message);\n`;
    logic += `        }\n`;
    logic += `      }\n\n`;
  }
  
  if (hasOpenAI || hasAnthropic) {
    logic += `      // AI analysis of data\n`;
    logic += `      let aiAnalysis = null;\n`;
    
    if (hasAnthropic) {
      logic += `      const anthropicKey = this.getAnthropicKey();\n`;
      logic += `      if (anthropicKey && stockData) {\n`;
      logic += `        try {\n`;
      logic += `          aiAnalysis = await AnthropicTool.analyzeStockData(anthropicKey, stockData, this.config.systemPrompt);\n`;
      logic += `          this.log("Generated AI analysis with Claude");\n`;
      logic += `        } catch (error: any) {\n`;
      logic += `          this.error("Claude analysis failed:", error.message);\n`;
      logic += `        }\n`;
      logic += `      }`
      
      if (hasOpenAI) {
        logic += ` else {\n        `;
      } else {
        logic += `\n\n`;
      }
    }
    
    if (hasOpenAI) {
      if (!hasAnthropic) logic += `      `;
      logic += `const openaiKey = this.getOpenAIKey();\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `if (openaiKey && stockData) {\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `  try {\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `    aiAnalysis = await OpenAITool.analyzeStockData(openaiKey, stockData, this.config.systemPrompt);\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `    this.log("Generated AI analysis with GPT-4");\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `  } catch (error: any) {\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `    this.error("OpenAI analysis failed:", error.message);\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `  }\n`;
      if (!hasAnthropic) logic += `      `;
      logic += `}\n`;
      
      if (hasAnthropic) {
        logic += `      }\n`;
      }
      logic += `\n`;
    }
  }
  
  if (hasCLI) {
    logic += `      // CLI Tool integration - execute shell commands\n`;
    logic += `      let cliResults = [];\n`;
    logic += `      if (input.command || input.commands) {\n`;
    logic += `        const commands = Array.isArray(input.commands) ? input.commands : [input.command].filter(Boolean);\n`;
    logic += `        \n`;
    logic += `        for (const cmd of commands) {\n`;
    logic += `          try {\n`;
    logic += `            if (typeof cmd === 'string') {\n`;
    logic += `              const [command, ...args] = cmd.split(' ');\n`;
    logic += `              const result = await CLITool.executeCommand(command, args);\n`;
    logic += `              cliResults.push({ command: cmd, ...result });\n`;
    logic += `              this.log(\`Executed command: \${cmd}\`, result.success ? '✅' : '❌');\n`;
    logic += `            }\n`;
    logic += `          } catch (error: any) {\n`;
    logic += `            this.error("CLI command failed:", error.message);\n`;
    logic += `            cliResults.push({ command: cmd, success: false, error: error.message });\n`;
    logic += `          }\n`;
    logic += `        }\n`;
    logic += `      }\n\n`;
  }
  
  if (tools.length === 0) {
    logic += `      // No tools selected - basic processing\n`;
    logic += `      const response = \`Processed input: \${JSON.stringify(input)}\`;\n`;
  }
  
  return { imports, logic };
}

/** Generate output structure based on output schema */
function generateOutputStructure(config: AgentConfig): string {
  const outputSchema = config.outputSchema || {};
  const fields = Object.keys(outputSchema);
  const tools = config.tools || [];
  const hasFinanceAPI = tools.some(t => typeof t === 'string' ? t === 'yahoo-finance' : t.id === 'yahoo-finance');
  const hasAI = tools.some(t => {
    const toolId = typeof t === 'string' ? t : t.id;
    return toolId === 'openai-api' || toolId === 'anthropic-api';
  });
  
  if (fields.length === 0) {
    return `result: aiAnalysis?.analysis || stockData?.quote?.currentPrice?.toString() || "Agent executed successfully",\n        `;
  }
  
  return fields.map(field => {
    const fieldSchema = outputSchema[field];
    const fieldType = fieldSchema?.type || 'string';
    
    // Map common field names to actual data
    let value;
    switch (field.toLowerCase()) {
      case 'current_price':
      case 'price':
        value = hasFinanceAPI ? 'stockData?.quote?.currentPrice || 0' : '0';
        break;
      case 'price_change':
      case 'change':
        value = hasFinanceAPI ? 'stockData?.quote?.priceChangePercent || 0' : '0';
        break;
      case 'analysis':
      case 'ai_analysis':
        value = hasAI ? 'aiAnalysis?.analysis || "Analysis not available"' : '"Analysis not available"';
        break;
      case 'recommendation':
        value = hasAI ? '(aiAnalysis?.analysis?.toLowerCase().includes("buy") ? "BUY" : aiAnalysis?.analysis?.toLowerCase().includes("sell") ? "SELL" : "HOLD")' : '"HOLD"';
        break;
      case 'risk_level':
      case 'risk':
        value = hasFinanceAPI ? 'stockData?.analysis?.riskLevel || "medium"' : '"medium"';
        break;
      case 'symbol':
        value = 'input.symbol || "N/A"';
        break;
      case 'key_metrics':
      case 'metrics':
        value = hasFinanceAPI ? 'stockData?.technicalIndicators || {}' : '{}';
        break;
      default:
        // Fallback based on field type
        switch (fieldType) {
          case 'number':
            value = hasFinanceAPI && field.includes('price') ? 'stockData?.quote?.currentPrice || 0' : '0';
            break;
          case 'boolean':
            value = 'true';
            break;
          case 'array':
            value = '[]';
            break;
          case 'object':
            value = '{}';
            break;
          default:
            value = hasAI && field.includes('result') ? 'aiAnalysis?.analysis || "No result"' : `"${field} result"`;
        }
    }
    
    return `${field}: ${value}, // ${fieldSchema?.description || 'Generated field'}`;
  }).join('\n        ') + '\n        ';
}
